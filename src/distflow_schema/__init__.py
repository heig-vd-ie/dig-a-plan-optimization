"""
Automatically generated by scripts from the changes in raw_data/models.
"""
from __future__ import annotations
import typing
from typing import TypedDict, Unpack, get_args, Optional
from dataclasses import dataclass, field, replace
import os
import tqdm
import duckdb
import polars as pl
import patito as pt

import distflow_schema
from distflow_schema.node_data import NodeData
from distflow_schema.edge_data import EdgeData

from general_function import snake_to_camel, build_non_existing_dirs

class DistFlowPolarsModel(TypedDict, total=False):
    node_data: pl.DataFrame
    edge_data: pl.DataFrame
    slack_node_id: Optional[int]
    s_base: Optional[float]

class DistFlowModel(TypedDict, total=False):
    node_data: pt.DataFrame[NodeData]
    edge_data: pt.DataFrame[EdgeData]
    slack_node_id: Optional[int]
    s_base: Optional[float]

def validate(**kwargs: Unpack[DistFlowModel]) -> None:
    for df in kwargs.values():
        df.validate() # type: ignore

@dataclass(frozen=True)
class DistFlowSchema:
    node_data: pt.DataFrame[NodeData] = field(default_factory=lambda: NodeData.DataFrame(schema=NodeData.columns).cast())
    edge_data: pt.DataFrame[EdgeData] = field(default_factory=lambda: EdgeData.DataFrame(schema=EdgeData.columns).cast())
    slack_node_id: Optional[int] = None
    s_base: Optional[float] = 100000.0

    def __post_init__(self):
        self.validate(**self.__dict__)

    def add_table(self,  **kwargs: Unpack[DistFlowPolarsModel]) -> DistFlowSchema:
        new_kwargs: DistFlowModel = self.cast_to_schema(**kwargs, replace_table=False)
        self.validate(**new_kwargs)
        return replace(self, **new_kwargs)

    def replace_table(self, **kwargs: Unpack[DistFlowPolarsModel]) -> DistFlowSchema:
        new_kwargs: DistFlowModel = self.cast_to_schema(**kwargs, replace_table=True)
        self.validate(**new_kwargs)
        return replace(self, **new_kwargs)
    
    def cast_to_schema(self, replace_table: bool, **kwargs: Unpack[DistFlowPolarsModel]) -> DistFlowModel:
        new_kwargs: DistFlowModel = {}
        for table_name, pl_table in kwargs.items():
            if table_name not in self.__dict__.keys():
                raise ValueError(f"{table_name} is not a valid name")
            if not isinstance(pl_table, pl.DataFrame):
                new_kwargs[table_name] = pl_table
            else:
                pt_table: pt.DataFrame = getattr(self, table_name)
                if replace_table:
                    pt_table = pt_table.clear() # type: ignore
                col_list: list[str] = list(set(pl_table.columns).intersection(set(pt_table.columns)))
                
                new_table: pl.DataFrame = pl.concat([pt_table, pl_table.select(col_list)], how="diagonal_relaxed")

                new_kwargs[table_name] = pt.DataFrame(new_table)\
                    .set_model(getattr(distflow_schema, snake_to_camel(table_name)))\
                    .fill_null(strategy="defaults").cast(strict=True)
        return new_kwargs

    def schema_to_duckdb(self, file_path: str):
        build_non_existing_dirs(file_path)
        if os.path.exists(file_path):
            os.remove(file_path)
        with duckdb.connect(file_path) as con:
            con.execute("SET TimeZone='UTC'")
            for table_name, table_pl in tqdm.tqdm(self.__dict__.items(), desc="Save raw data into duckdb file", ncols=150):
                query = f"CREATE TABLE {table_name} AS SELECT * FROM table_pl"
                con.execute(query)

    def duckdb_to_schema(self, file_path: str) -> DistFlowSchema:
        schema_dict: dict[str, pt.Model.DataFrame] = {} # type: ignore
        pbar = tqdm.tqdm(
            total=1, ncols=150, desc="Read and validate tables from {} file".format(os.path.basename(file_path)))
        with pbar:
            with duckdb.connect(database=file_path) as con:
                con.execute("SET TimeZone='UTC'")
                query = "SELECT table_name FROM information_schema.tables WHERE table_schema = 'main'"
                for table_name in con.execute(query).fetchall():
                    query: str = f"SELECT * FROM {table_name[0]}"
                    schema_dict[table_name[0]] = con.execute(query).pl()
        return self.add_table(**schema_dict)
    
    def validate(self, **kwargs: Unpack[DistFlowModel]) -> None:
        for value_name, value in kwargs.items():
            if isinstance(value, pt.DataFrame):
                value.validate() # type: ignore
            else:
                value_type = get_args(eval(self.__annotations__.get(value_name))) # type: ignore
                if not isinstance(value, value_type): # type: ignore
                    raise ValueError(f"{value_name} is not a {value_type}") # type: ignore
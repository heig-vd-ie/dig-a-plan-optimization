r"""

1. Dantzig–Wolfe Master Problem Constraints
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This section describes the optimization model used in the **Dantzig–Wolfe master problem**, which combines columns generated by DistFlow slave model to reconstruct a feasible network topology and configuration. The master selects the optimal convex combination of these columns using variables :math:`\lambda_k`.

2. Objective Function
~~~~~~~~~~~~~~~~~~~~~~~~~

.. math::
    :label: dw-objective
    :nowrap:

    \begin{align}
        \min \sum_{k \in K} \text{cost}_k \cdot \lambda_k
    \end{align}

- The objective minimizes the total cost over all selected columns.

3. Convexity Constraint
~~~~~~~~~~~~~~~~~~~~~~~~~~~

The convexity constraint ensures that the solution is a convex combination of columns:

.. math::
    :label: dw-convexity
    :nowrap:

    \begin{align}
        \sum_{k \in K} \lambda_k = 1
    \end{align}

- This guarantees that the weights assigned to all columns sum to one.

4. Coupling Constraints
~~~~~~~~~~~~~~~~~~~~~~~~~~~

For every candidate connection :math:`(l~ i~ j) \in LC`, the master problem enforces that the selected combination of columns respects the current network configuration as determined by binary variables :math:`\delta_l`:

.. math::
    :label: dw-coupling
    :nowrap:

    \begin{align}
        \sum_{k \in K} d^k_{l~i~j} \cdot \lambda_k = \delta_l, \quad \forall (l~ i~ j) \in LC
    \end{align}

- Here, :math:`d^k_{l~i~j}` is the binary indicator showing if connection :math:`(l~ i~ j)` is present in column :math:`k`.
- :math:`\delta_l` is the binary decision variable indicating if branch :math:`l` is active in the master solution.

Notes
~~~~~~

- The sets :math:`K` and :math:`LC` are dynamic and grow as more columns are generated by the DistFlow slave model.
- This formulation ensures the master problem maintains consistency with feasible configurations provided by the DistFlow slave model, and that exactly one configuration is selected via the convexity constraint.

"""


import pyomo.environ as pyo
from pyomo.environ import ConstraintList

def D_W_model_constraints(model: pyo.AbstractModel) -> pyo.AbstractModel:
    # objective in λ only
    model.objective = pyo.Objective(rule=D_W_obj, sense=pyo.minimize)

    # CONVEXITY: one row, rebuilt whenever model.K changes
    #model.convexity = pyo.Constraint(rule=convexity_rule)
    model.convexity = ConstraintList()

    # COUPLING: one row per (l,i,j) ∈ LC, rebuilt when K (or LC) changes
    #model.coupling  = pyo.Constraint(model.LC, rule=coupling_rule)
    model.coupling  = ConstraintList()

    return model

def D_W_obj(m):
    return sum(m.column_cost[k] * m.lambda_k[k] for k in m.K)

def convexity_rule(m):
    # skip until we have at least one column
    if not m.K:
        return pyo.Constraint.Skip
    return sum(m.lambda_k[k] for k in m.K) == 1

def coupling_rule(m, l, i, j):
    # skip until we have at least one column
    if not m.K:
        return pyo.Constraint.Skip
    return sum(m.column_d[k, (l, i, j)] * m.lambda_k[k] for k in m.K) == m.delta[l]
